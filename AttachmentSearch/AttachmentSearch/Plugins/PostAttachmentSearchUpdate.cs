// <copyright file="PostAttachmentSearchUpdate.cs" company="Microsoft">
// Copyright (c) 2014 All Rights Reserved
// </copyright>
// <author>Microsoft</author>
// <date>12/22/2014 5:16:45 PM</date>
// <summary>Implements the PostAttachmentSearchUpdate Plugin.</summary>
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1
// </auto-generated>
namespace AttachmentSearch.Plugins
{


    using System.Collections.Generic;
    using System.Text;
    using Microsoft.Crm.Sdk;
    using System.Xml;
    using System.Data.SqlClient;
    using System;
    using System.ServiceModel;
    using Microsoft.Xrm.Sdk;
    using Microsoft.Xrm.Sdk.Query;
    using System.Linq;

    /// <summary>
    /// PostAttachmentSearchUpdate Plugin.
    /// Fires when the following attributes are updated:
    /// new_searchword
    /// </summary>    
    public class PostAttachmentSearchUpdate : Plugin
    {
        //define the EntityCollection that holds the values from the pages
        public EntityCollection fullListOfEntities = new EntityCollection();
        public StringBuilder ParticipantsCollection = new StringBuilder();
        /// <summary>
        /// Initializes a new instance of the <see cref="PostAttachmentSearchUpdate"/> class.
        /// </summary>
        public PostAttachmentSearchUpdate()
            : base(typeof(PostAttachmentSearchUpdate))
        {
            base.RegisteredEvents.Add(new Tuple<int, string, string, Action<LocalPluginContext>>(40, "Update", "new_attachmentsearch", new Action<LocalPluginContext>(ExecutePostAttachmentSearchUpdate)));

            // Note : you can register for more events here if this plugin is not specific to an individual entity and message combination.
            // You may also need to update your RegisterFile.crmregister plug-in registration file to reflect any change.
        }

        /// <summary>
        /// Executes the plug-in.
        /// </summary>
        /// <param name="localContext">The <see cref="LocalPluginContext"/> which contains the
        /// <see cref="IPluginExecutionContext"/>,
        /// <see cref="IOrganizationService"/>
        /// and <see cref="ITracingService"/>
        /// </param>
        /// <remarks>
        /// For improved performance, Microsoft Dynamics CRM caches plug-in instances.
        /// The plug-in's Execute method should be written to be stateless as the constructor
        /// is not called for every invocation of the plug-in. Also, multiple system threads
        /// could execute the plug-in at the same time. All per invocation state information
        /// is stored in the context. This means that you should not use global variables in plug-ins.
        /// </remarks>
        /// 
        
        protected void ExecutePostAttachmentSearchUpdate(LocalPluginContext localContext)
        {
            if (localContext == null)
            {
                throw new ArgumentNullException("localContext");
            }

            // TODO: Implement your custom Plug-in business logic.
            IPluginExecutionContext context = localContext.PluginExecutionContext;
            IOrganizationService service = localContext.OrganizationService;

            

            Guid searchID = (Guid)((Entity)context.InputParameters["Target"]).Id;
            ColumnSet set = new ColumnSet();
            set.AllColumns = true;


            var searchEntity = service.Retrieve("new_attachmentsearch", searchID, set);

            if (context.Depth > 1)
            {
                searchEntity["new_results"] = "This created a loop!";
                return;
            }
            else
            {
                //acquires the keyword

                string keywordToLook = (string)searchEntity["new_searchword"];
                var countPerPage = 20;
                    //(int)searchEntity["new_countperpage"];
                var pagesCount = (int)searchEntity["new_numberofpages"];
                var lastPage = 1;
                var firstPage = 1;

                //creates the critieria of the query
                ColumnSet NoteSet = new ColumnSet(new string[] { "filename", "documentbody", "subject" });
                QueryExpression Notes = new QueryExpression { EntityName = "annotation", ColumnSet = NoteSet };
                Notes.PageInfo = new PagingInfo();
                Notes.PageInfo.Count = countPerPage;
                Notes.Criteria.AddCondition("documentbody", ConditionOperator.NotNull);

                //retrieve the Notes that fulfill the condition
                searchEntity["new_results"] = "";

                for (int i = firstPage; i < lastPage; i++)
                {
                      var NotesRetrieved = fillCollection(Notes, pagesCount, service);
                      searchForKeyWord(keywordToLook, searchEntity, NotesRetrieved, pagesCount);
                }

                //EntityCollection fullListOfEntities = new EntityCollection();
                // searchEntity["new_results"] += "\r\n" + keywordToLook;
            }
            service.Update(searchEntity);
        }

        public EntityCollection fillCollection(QueryExpression NotesQuery, int pageCount, IOrganizationService service)
        {
            //int i = (int)NotesQuery.PageInfo.PageNumber;

            //for (int startingPage = pageCount; startingPage <= pageCount + 2; startingPage++)
            //{
                NotesQuery.PageInfo.PageNumber = pageCount;
                EntityCollection NotesRetrieve = service.RetrieveMultiple(NotesQuery);
                //fullListOfEntities.Entities.AddRange(NotesRetrieve.Entities);
            //}
                return NotesRetrieve;
        }
        public void searchForKeyWord(string keywordToLook, Entity entityToBeSearched, EntityCollection NotesRetrieved, int pagesCount)
        {
            //int j = 0;
            foreach (var note in NotesRetrieved.Entities)
            {

                //var NoteReference = new EntityReference("annotation", new Guid(note.Attributes["objectid"].ToString()));
                byte[] fileContent = Convert.FromBase64String(note.Attributes["documentbody"].ToString());
                string content = System.Text.Encoding.GetEncoding(1251).GetString(fileContent, 0, fileContent.Length);

                //check if the keyword is contained
                if (content.Contains(keywordToLook))
                {
                    //j++;
                    ParticipantsCollection.AppendLine(note.Attributes["filename"].ToString());
                    //entityToBeSearched["new_results"] += "\r\n" + note.Attributes["filename"];
                    //fullListOfEntities.Entities.AddRange(NotesRetrieved.Entities);
                }
            }
            entityToBeSearched["new_results"] = "Page: " + pagesCount + ""  + "\r\n" + entityToBeSearched["new_results"];
        }
        private Guid findCvOwner(string customerName, IOrganizationService service)
        {

            ConditionExpression condition = new ConditionExpression();
            condition.AttributeName = "name";
            condition.Operator = ConditionOperator.Equal;
            condition.Values.Add(customerName);

            FilterExpression filter = new FilterExpression();
            filter.AddCondition(condition);

            QueryExpression query = new QueryExpression();
            query.EntityName = "account";
            query.ColumnSet = new ColumnSet(true);
            query.Criteria = filter;

            try
            {
                EntityCollection result = service.RetrieveMultiple(query);
                var accountid = Guid.Empty;

                accountid = result.Entities.FirstOrDefault().Id;
                return accountid;
            }
            catch (Exception)
            {
                throw new Exception("The user was not be found");
            }
        }
    }
}
