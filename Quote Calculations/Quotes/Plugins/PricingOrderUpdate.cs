//// <copyright file="PostOrderProductUpdate.cs" company="Microsoft">
//// Copyright (c) 2015 All Rights Reserved
//// </copyright>
//// <author>Microsoft</author>
//// <date>3/16/2015 9:54:42 AM</date>
//// <summary>Implements the PostOrderProductUpdate Plugin.</summary>
//// <auto-generated>
////     This code was generated by a tool.
////     Runtime Version:4.0.30319.1
//// </auto-generated>
//namespace Quotes.Plugins
//{
//    using System;
//    using System.ServiceModel;
//    using Microsoft.Xrm.Sdk;
//    using Microsoft.Xrm.Sdk.Query;

//    /// <summary>
//    /// ONCHANGE OF THE PRICING TYPE !!!!!!!!!!!!!!!!! NOT WORKING / DELETED
//    /// 
//    /// PostOrderProductUpdate Plugin.
//    /// Fires when the following attributes are updated:
//    /// new_pricingtype
//    /// </summary>    
//    public class PostOrderProductUpdate : Plugin
//    {
//        /// <summary>
//        /// Initializes a new instance of the <see cref="PostOrderProductUpdate"/> class.
//        /// </summary>
//        public PostOrderProductUpdate()
//            : base(typeof(PostOrderProductUpdate))
//        {
//            base.RegisteredEvents.Add(new Tuple<int, string, string, Action<LocalPluginContext>>(40, "Update", "salesorderdetail", new Action<LocalPluginContext>(ExecutePostOrderProductUpdate)));

//            // Note : you can register for more events here if this plugin is not specific to an individual entity and message combination.
//            // You may also need to update your RegisterFile.crmregister plug-in registration file to reflect any change.
//        }

//        /// <summary>
//        /// Executes the plug-in.
//        /// </summary>
//        /// <param name="localContext">The <see cref="LocalPluginContext"/> which contains the
//        /// <see cref="IPluginExecutionContext"/>,
//        /// <see cref="IOrganizationService"/>
//        /// and <see cref="ITracingService"/>
//        /// </param>
//        /// <remarks>
//        /// For improved performance, Microsoft Dynamics CRM caches plug-in instances.
//        /// The plug-in's Execute method should be written to be stateless as the constructor
//        /// is not called for every invocation of the plug-in. Also, multiple system threads
//        /// could execute the plug-in at the same time. All per invocation state information
//        /// is stored in the context. This means that you should not use global variables in plug-ins.
//        /// </remarks>
//        protected void ExecutePostOrderProductUpdate(LocalPluginContext localContext)
//        {
//            if (localContext == null)
//            {
//                throw new ArgumentNullException("localContext");
//            }
//            // TODO: Implement your custom Plug-in business logic.

//            IPluginExecutionContext context = localContext.PluginExecutionContext;
//            IOrganizationService service = localContext.OrganizationService;
//            Guid orderProductID = (Guid)((Entity)context.InputParameters["Target"]).Id;
//            ColumnSet set = new ColumnSet();
//            set.AllColumns = true;
//            var order = service.Retrieve("salesorder", orderProductID, set);


//            if (context.Depth > 1)
//            {
//                return;
//            }
//            else
//            {

//                //First I get the base values that I need for the calculations

//                var pricingType = (OptionSetValue)order["new_pricingtype"];

//                ConditionExpression condition = new ConditionExpression();
//                condition.AttributeName = "salesorderid";
//                condition.Operator = ConditionOperator.Equal;
//                condition.Values.Add(orderProductID);

//                FilterExpression filter = new FilterExpression();
//                filter.AddCondition(condition);

//                QueryExpression query = new QueryExpression();
//                query.EntityName = "salesorderdetail";
//                query.ColumnSet = new ColumnSet(true);
//                query.Criteria = filter;

//                EntityCollection salesorderDetail = service.RetrieveMultiple(query);

//                foreach (var detail in salesorderDetail.Entities)
//                {
//                    detail["new_pricingtype"] = new OptionSetValue(pricingType.Value);
//                    service.Update(detail);
//                }


//                service.Update(order);

//            }
//        }
//    }
//}
